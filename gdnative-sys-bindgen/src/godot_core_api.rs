/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201605;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 24;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const GODOT_API_VERSION: ::std::os::raw::c_uint = 1;
pub const GODOT_TRUE: ::std::os::raw::c_uint = 1;
pub const GODOT_FALSE: ::std::os::raw::c_uint = 0;
pub const _WCHAR_H: ::std::os::raw::c_uint = 1;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const __mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const WEOF: ::std::os::raw::c_uint = 4294967295;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub type int_least8_t = ::std::os::raw::c_char;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_char;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub const godot_error_GODOT_ERR_WTF: godot_error =
    godot_error::GODOT_ERR_OMFG_THIS_IS_VERY_VERY_BAD;
#[repr(u32)]
////// Error
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum godot_error {
    GODOT_OK = 0,
    GODOT_FAILED = 1,
    GODOT_ERR_UNAVAILABLE = 2,
    GODOT_ERR_UNCONFIGURED = 3,
    GODOT_ERR_UNAUTHORIZED = 4,
    GODOT_ERR_PARAMETER_RANGE_ERROR = 5,
    GODOT_ERR_OUT_OF_MEMORY = 6,
    GODOT_ERR_FILE_NOT_FOUND = 7,
    GODOT_ERR_FILE_BAD_DRIVE = 8,
    GODOT_ERR_FILE_BAD_PATH = 9,
    GODOT_ERR_FILE_NO_PERMISSION = 10,
    GODOT_ERR_FILE_ALREADY_IN_USE = 11,
    GODOT_ERR_FILE_CANT_OPEN = 12,
    GODOT_ERR_FILE_CANT_WRITE = 13,
    GODOT_ERR_FILE_CANT_READ = 14,
    GODOT_ERR_FILE_UNRECOGNIZED = 15,
    GODOT_ERR_FILE_CORRUPT = 16,
    GODOT_ERR_FILE_MISSING_DEPENDENCIES = 17,
    GODOT_ERR_FILE_EOF = 18,
    GODOT_ERR_CANT_OPEN = 19,
    GODOT_ERR_CANT_CREATE = 20,
    GODOT_ERR_QUERY_FAILED = 21,
    GODOT_ERR_ALREADY_IN_USE = 22,
    GODOT_ERR_LOCKED = 23,
    GODOT_ERR_TIMEOUT = 24,
    GODOT_ERR_CANT_CONNECT = 25,
    GODOT_ERR_CANT_RESOLVE = 26,
    GODOT_ERR_CONNECTION_ERROR = 27,
    GODOT_ERR_CANT_AQUIRE_RESOURCE = 28,
    GODOT_ERR_CANT_FORK = 29,
    GODOT_ERR_INVALID_DATA = 30,
    GODOT_ERR_INVALID_PARAMETER = 31,
    GODOT_ERR_ALREADY_EXISTS = 32,
    GODOT_ERR_DOES_NOT_EXIST = 33,
    GODOT_ERR_DATABASE_CANT_READ = 34,
    GODOT_ERR_DATABASE_CANT_WRITE = 35,
    GODOT_ERR_COMPILATION_FAILED = 36,
    GODOT_ERR_METHOD_NOT_FOUND = 37,
    GODOT_ERR_LINK_FAILED = 38,
    GODOT_ERR_SCRIPT_FAILED = 39,
    GODOT_ERR_CYCLIC_LINK = 40,
    GODOT_ERR_INVALID_DECLARATION = 41,
    GODOT_ERR_DUPLICATE_SYMBOL = 42,
    GODOT_ERR_PARSE_ERROR = 43,
    GODOT_ERR_BUSY = 44,
    GODOT_ERR_SKIP = 45,
    GODOT_ERR_HELP = 46,
    GODOT_ERR_BUG = 47,
    GODOT_ERR_PRINTER_ON_FIRE = 48,
    GODOT_ERR_OMFG_THIS_IS_VERY_VERY_BAD = 49,
}
////// bool
pub type godot_bool = bool;
/////// int
pub type godot_int = ::std::os::raw::c_int;
/////// real
pub type godot_real = f32;
/////// Object (forward declared)
pub type godot_object = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE([u8; 0]);
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<::std::os::raw::c_uint>,
    pub __wchb: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type mbstate_t = __mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm([u8; 0]);
extern "C" {
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(__s1: *const wchar_t, __s2: *const wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncmp(__s1: *const wchar_t, __s2: *const wchar_t, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp(__s1: *const wchar_t, __s2: *const wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp(__s1: *const wchar_t, __s2: *const wchar_t, __n: usize)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
               ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __locales as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __names as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn wcscasecmp_l(__s1: *const wchar_t, __s2: *const wchar_t,
                        __loc: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp_l(__s1: *const wchar_t, __s2: *const wchar_t,
                         __n: usize, __loc: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize)
     -> usize;
}
extern "C" {
    pub fn wcscoll_l(__s1: *const wchar_t, __s2: *const wchar_t,
                     __loc: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm_l(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize,
                     __loc: __locale_t) -> usize;
}
extern "C" {
    pub fn wcsdup(__s: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcschr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcstok(__s: *mut wchar_t, __delim: *const wchar_t,
                  __ptr: *mut *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslen(__s: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsnlen(__s: *const wchar_t, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn wmemchr(__s: *const wchar_t, __c: wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wmemcmp(__s1: *const wchar_t, __s2: *const wchar_t, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wmemmove(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn btowc(__c: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn wctob(__c: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbrtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                   __n: usize, __p: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcrtomb(__s: *mut ::std::os::raw::c_char, __wc: wchar_t,
                   __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn __mbrlen(__s: *const ::std::os::raw::c_char, __n: usize,
                    __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbrlen(__s: *const ::std::os::raw::c_char, __n: usize,
                  __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbsrtowcs(__dst: *mut wchar_t,
                     __src: *mut *const ::std::os::raw::c_char, __len: usize,
                     __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcsrtombs(__dst: *mut ::std::os::raw::c_char,
                     __src: *mut *const wchar_t, __len: usize,
                     __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbsnrtowcs(__dst: *mut wchar_t,
                      __src: *mut *const ::std::os::raw::c_char, __nmc: usize,
                      __len: usize, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcsnrtombs(__dst: *mut ::std::os::raw::c_char,
                      __src: *mut *const wchar_t, __nwc: usize, __len: usize,
                      __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn wcstold(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t)
     -> f64;
}
extern "C" {
    pub fn wcstol(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoll(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcpcpy(__dest: *mut wchar_t, __src: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcpncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut wchar_t, __sizeloc: *mut usize)
     -> *mut __FILE;
}
extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swprintf(__s: *mut wchar_t, __n: usize,
                    __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwprintf(__s: *mut __FILE, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf(__s: *mut wchar_t, __n: usize, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf(__s: *const wchar_t, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_swscanf"]
    pub fn swscanf1(__s: *const wchar_t, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf(__s: *mut __FILE, __format: *const wchar_t,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf(__s: *const wchar_t, __format: *const wchar_t,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfwscanf"]
    pub fn vfwscanf1(__s: *mut __FILE, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const wchar_t, __arg: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vswscanf"]
    pub fn vswscanf1(__s: *const wchar_t, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
extern "C" {
    pub fn fgetws(__ws: *mut wchar_t, __n: ::std::os::raw::c_int,
                  __stream: *mut __FILE) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(__ws: *const wchar_t, __stream: *mut __FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn wcsftime(__s: *mut wchar_t, __maxsize: usize,
                    __format: *const wchar_t, __tp: *const tm) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_string {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_string() {
    assert_eq!(::std::mem::size_of::<godot_string>() , 8usize , concat ! (
               "Size of: " , stringify ! ( godot_string ) ));
    assert_eq! (::std::mem::align_of::<godot_string>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_string ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_string ) ) . _dont_touch_that as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_string ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_string {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_string_new(p_str: *mut godot_string);
}
extern "C" {
    pub fn godot_string_new_data(p_str: *mut godot_string,
                                 p_contents: *const ::std::os::raw::c_char,
                                 p_size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn godot_string_get_data(p_str: *const godot_string,
                                 p_dest: *mut wchar_t,
                                 p_size: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn godot_string_copy_string(p_dest: *const godot_string,
                                    p_src: *const godot_string);
}
extern "C" {
    pub fn godot_string_operator_index(p_str: *mut godot_string,
                                       p_idx: godot_int) -> *mut wchar_t;
}
extern "C" {
    pub fn godot_string_c_str(p_str: *const godot_string) -> *const wchar_t;
}
extern "C" {
    pub fn godot_string_operator_equal(p_a: *const godot_string,
                                       p_b: *const godot_string)
     -> godot_bool;
}
extern "C" {
    pub fn godot_string_operator_less(p_a: *const godot_string,
                                      p_b: *const godot_string) -> godot_bool;
}
extern "C" {
    pub fn godot_string_operator_plus(p_dest: *mut godot_string,
                                      p_a: *const godot_string,
                                      p_b: *const godot_string);
}
extern "C" {
    pub fn godot_string_destroy(p_str: *mut godot_string);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_vector2 {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_vector2() {
    assert_eq!(::std::mem::size_of::<godot_vector2>() , 8usize , concat ! (
               "Size of: " , stringify ! ( godot_vector2 ) ));
    assert_eq! (::std::mem::align_of::<godot_vector2>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_vector2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_vector2 ) ) . _dont_touch_that as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_vector2 ) , "::"
                , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_vector2 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_vector2_new(p_v: *mut godot_vector2, p_x: godot_real,
                             p_y: godot_real);
}
extern "C" {
    pub fn godot_vector2_set_x(p_v: *mut godot_vector2, p_x: godot_real);
}
extern "C" {
    pub fn godot_vector2_set_y(p_v: *mut godot_vector2, p_y: godot_real);
}
extern "C" {
    pub fn godot_vector2_get_x(p_v: *const godot_vector2) -> godot_real;
}
extern "C" {
    pub fn godot_vector2_get_y(p_v: *const godot_vector2) -> godot_real;
}
extern "C" {
    pub fn godot_vector2_normalize(p_v: *mut godot_vector2);
}
extern "C" {
    pub fn godot_vector2_normalized(p_dest: *mut godot_vector2,
                                    p_src: *const godot_vector2);
}
extern "C" {
    pub fn godot_vector2_length(p_v: *const godot_vector2) -> godot_real;
}
extern "C" {
    pub fn godot_vector2_length_squared(p_v: *const godot_vector2)
     -> godot_real;
}
extern "C" {
    pub fn godot_vector2_distance_to(p_a: *const godot_vector2,
                                     p_b: *const godot_vector2) -> godot_real;
}
extern "C" {
    pub fn godot_vector2_distance_squared_to(p_a: *const godot_vector2,
                                             p_b: *const godot_vector2)
     -> godot_real;
}
extern "C" {
    pub fn godot_vector2_operator_add(p_dest: *mut godot_vector2,
                                      p_a: *const godot_vector2,
                                      p_b: *const godot_vector2);
}
extern "C" {
    pub fn godot_vector2_operator_subtract(p_dest: *mut godot_vector2,
                                           p_a: *const godot_vector2,
                                           p_b: *const godot_vector2);
}
extern "C" {
    pub fn godot_vector2_operator_multiply_vector(p_dest: *mut godot_vector2,
                                                  p_a: *const godot_vector2,
                                                  p_b: *const godot_vector2);
}
extern "C" {
    pub fn godot_vector2_operator_multiply_scalar(p_dest: *mut godot_vector2,
                                                  p_a: *const godot_vector2,
                                                  p_b: godot_real);
}
extern "C" {
    pub fn godot_vector2_operator_divide_vector(p_dest: *mut godot_vector2,
                                                p_a: *const godot_vector2,
                                                p_b: *const godot_vector2);
}
extern "C" {
    pub fn godot_vector2_operator_divide_scalar(p_dest: *mut godot_vector2,
                                                p_a: *const godot_vector2,
                                                p_b: godot_real);
}
extern "C" {
    pub fn godot_vector2_operator_equal(p_a: *const godot_vector2,
                                        p_b: *const godot_vector2)
     -> godot_bool;
}
extern "C" {
    pub fn godot_vector2_operator_less(p_a: *const godot_vector2,
                                       p_b: *const godot_vector2)
     -> godot_bool;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_rect2 {
    pub _dont_touch_that: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_godot_rect2() {
    assert_eq!(::std::mem::size_of::<godot_rect2>() , 16usize , concat ! (
               "Size of: " , stringify ! ( godot_rect2 ) ));
    assert_eq! (::std::mem::align_of::<godot_rect2>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_rect2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_rect2 ) ) . _dont_touch_that as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_rect2 ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_rect2 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_rect2_new(p_rect: *mut godot_rect2);
}
extern "C" {
    pub fn godot_rect2_new_with_pos_and_size(p_rect: *mut godot_rect2,
                                             p_pos: *const godot_vector2,
                                             p_size: *const godot_vector2);
}
extern "C" {
    pub fn godot_rect2_get_pos(p_rect: *mut godot_rect2)
     -> *mut godot_vector2;
}
extern "C" {
    pub fn godot_rect2_set_pos(p_rect: *mut godot_rect2,
                               p_pos: *const godot_vector2);
}
extern "C" {
    pub fn godot_rect2_get_size(p_rect: *mut godot_rect2)
     -> *mut godot_vector2;
}
extern "C" {
    pub fn godot_rect2_set_size(p_rect: *mut godot_rect2,
                                p_size: *const godot_vector2);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_vector3 {
    pub _dont_touch_that: [u8; 12usize],
}
#[test]
fn bindgen_test_layout_godot_vector3() {
    assert_eq!(::std::mem::size_of::<godot_vector3>() , 12usize , concat ! (
               "Size of: " , stringify ! ( godot_vector3 ) ));
    assert_eq! (::std::mem::align_of::<godot_vector3>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_vector3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_vector3 ) ) . _dont_touch_that as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_vector3 ) , "::"
                , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_vector3 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_vector3_new(p_v: *mut godot_vector3, p_x: godot_real,
                             p_y: godot_real, p_z: godot_real);
}
extern "C" {
    pub fn godot_vector3_set_axis(p_v: *mut godot_vector3, p_axis: godot_int,
                                  p_val: godot_real);
}
extern "C" {
    pub fn godot_vector3_get_axis(p_v: *const godot_vector3,
                                  p_axis: godot_int) -> godot_real;
}
extern "C" {
    pub fn godot_vector3_min_axis(p_v: *const godot_vector3) -> godot_int;
}
extern "C" {
    pub fn godot_vector3_max_axis(p_v: *const godot_vector3) -> godot_int;
}
extern "C" {
    pub fn godot_vector3_length(p_v: *const godot_vector3) -> godot_real;
}
extern "C" {
    pub fn godot_vector3_length_squared(p_v: *const godot_vector3)
     -> godot_real;
}
extern "C" {
    pub fn godot_vector3_normalize(p_v: *mut godot_vector3);
}
extern "C" {
    pub fn godot_vector3_normalized(p_dest: *mut godot_vector3,
                                    p_src: *const godot_vector3);
}
extern "C" {
    pub fn godot_vector3_distance_to(p_a: *const godot_vector3,
                                     p_b: *const godot_vector3) -> godot_real;
}
extern "C" {
    pub fn godot_vector3_distance_squared_to(p_a: *const godot_vector3,
                                             p_b: *const godot_vector3)
     -> godot_real;
}
extern "C" {
    pub fn godot_vector3_operator_add(p_dest: *mut godot_vector3,
                                      p_a: *const godot_vector3,
                                      p_b: *const godot_vector3);
}
extern "C" {
    pub fn godot_vector3_operator_subtract(p_dest: *mut godot_vector3,
                                           p_a: *const godot_vector3,
                                           p_b: *const godot_vector3);
}
extern "C" {
    pub fn godot_vector3_operator_multiply_vector(p_dest: *mut godot_vector3,
                                                  p_a: *const godot_vector3,
                                                  p_b: *const godot_vector3);
}
extern "C" {
    pub fn godot_vector3_operator_multiply_scalar(p_dest: *mut godot_vector3,
                                                  p_a: *const godot_vector3,
                                                  p_b: godot_real);
}
extern "C" {
    pub fn godot_vector3_operator_divide_vector(p_dest: *mut godot_vector3,
                                                p_a: *const godot_vector3,
                                                p_b: *const godot_vector3);
}
extern "C" {
    pub fn godot_vector3_operator_divide_scalar(p_dest: *mut godot_vector3,
                                                p_a: *const godot_vector3,
                                                p_b: godot_real);
}
extern "C" {
    pub fn godot_vector3_operator_equal(p_a: *const godot_vector3,
                                        p_b: *const godot_vector3)
     -> godot_bool;
}
extern "C" {
    pub fn godot_vector3_operator_less(p_a: *const godot_vector3,
                                       p_b: *const godot_vector3)
     -> godot_bool;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_transform2d {
    pub _dont_touch_that: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_godot_transform2d() {
    assert_eq!(::std::mem::size_of::<godot_transform2d>() , 24usize , concat !
               ( "Size of: " , stringify ! ( godot_transform2d ) ));
    assert_eq! (::std::mem::align_of::<godot_transform2d>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( godot_transform2d ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_transform2d ) ) . _dont_touch_that
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_transform2d ) ,
                "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_transform2d {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_transform2d_new_identity(p_t: *mut godot_transform2d);
}
extern "C" {
    pub fn godot_transform2d_new_elements(p_t: *mut godot_transform2d,
                                          p_a: *const godot_vector2,
                                          p_b: *const godot_vector2,
                                          p_c: *const godot_vector2);
}
extern "C" {
    pub fn godot_transform2d_new(p_t: *mut godot_transform2d,
                                 p_rot: godot_real,
                                 p_pos: *const godot_vector2);
}
extern "C" {
    pub fn godot_transform2d_const_index(p_t: *const godot_transform2d,
                                         p_idx: godot_int)
     -> *const godot_vector2;
}
extern "C" {
    pub fn godot_transform2d_index(p_t: *mut godot_transform2d,
                                   p_idx: godot_int) -> *mut godot_vector2;
}
extern "C" {
    pub fn godot_transform2d_get_axis(p_t: *const godot_transform2d,
                                      p_axis: godot_int) -> godot_vector2;
}
extern "C" {
    pub fn godot_transform2d_set_axis(p_t: *mut godot_transform2d,
                                      p_axis: godot_int,
                                      p_vec: *const godot_vector2);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_plane {
    pub _dont_touch_that: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_godot_plane() {
    assert_eq!(::std::mem::size_of::<godot_plane>() , 16usize , concat ! (
               "Size of: " , stringify ! ( godot_plane ) ));
    assert_eq! (::std::mem::align_of::<godot_plane>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_plane ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_plane ) ) . _dont_touch_that as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_plane ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_plane {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_plane_new(p_pl: *mut godot_plane);
}
extern "C" {
    pub fn godot_plane_new_with_normal(p_pl: *mut godot_plane,
                                       p_normal: *const godot_vector3,
                                       p_d: godot_real);
}
extern "C" {
    pub fn godot_plane_set_normal(p_pl: *mut godot_plane,
                                  p_normal: *const godot_vector3);
}
extern "C" {
    pub fn godot_plane_get_normal(p_pl: *const godot_plane) -> godot_vector3;
}
extern "C" {
    pub fn godot_plane_get_d(p_pl: *const godot_plane) -> godot_real;
}
extern "C" {
    pub fn godot_plane_set_d(p_pl: *mut godot_plane, p_d: godot_real);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_quat {
    pub _dont_touch_that: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_godot_quat() {
    assert_eq!(::std::mem::size_of::<godot_quat>() , 16usize , concat ! (
               "Size of: " , stringify ! ( godot_quat ) ));
    assert_eq! (::std::mem::align_of::<godot_quat>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_quat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_quat ) ) . _dont_touch_that as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_quat ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_quat {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_quat_new(p_quat: *mut godot_quat);
}
extern "C" {
    pub fn godot_quat_new_with_elements(p_quat: *mut godot_quat,
                                        x: godot_real, y: godot_real,
                                        z: godot_real, w: godot_real);
}
extern "C" {
    pub fn godot_quat_new_with_rotation(p_quat: *mut godot_quat,
                                        p_axis: *const godot_vector3,
                                        p_angle: godot_real);
}
extern "C" {
    pub fn godot_quat_new_with_shortest_arc(p_quat: *mut godot_quat,
                                            p_v0: *const godot_vector3,
                                            p_v1: *const godot_vector3);
}
extern "C" {
    pub fn godot_quat_get_euler(p_quat: *const godot_quat) -> godot_vector3;
}
extern "C" {
    pub fn godot_quat_set_euler(p_quat: *mut godot_quat,
                                p_euler: *const godot_vector3);
}
extern "C" {
    pub fn godot_quat_index(p_quat: *mut godot_quat, p_idx: godot_int)
     -> *mut godot_real;
}
extern "C" {
    pub fn godot_quat_const_index(p_quat: *const godot_quat, p_idx: godot_int)
     -> godot_real;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_rect3 {
    pub _dont_touch_that: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_godot_rect3() {
    assert_eq!(::std::mem::size_of::<godot_rect3>() , 24usize , concat ! (
               "Size of: " , stringify ! ( godot_rect3 ) ));
    assert_eq! (::std::mem::align_of::<godot_rect3>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_rect3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_rect3 ) ) . _dont_touch_that as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_rect3 ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_rect3 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_rect3_new(p_rect: *mut godot_rect3);
}
extern "C" {
    pub fn godot_rect3_new_with_pos_and_size(p_rect: *mut godot_rect3,
                                             p_pos: *const godot_vector3,
                                             p_size: *const godot_vector3);
}
extern "C" {
    pub fn godot_rect3_get_pos(p_rect: *mut godot_rect3)
     -> *mut godot_vector3;
}
extern "C" {
    pub fn godot_rect3_set_pos(p_rect: *mut godot_rect3,
                               p_pos: *const godot_vector3);
}
extern "C" {
    pub fn godot_rect3_get_size(p_rect: *mut godot_rect3)
     -> *mut godot_vector3;
}
extern "C" {
    pub fn godot_rect3_set_size(p_rect: *mut godot_rect3,
                                p_size: *const godot_vector3);
}
#[repr(C)]
pub struct godot_basis {
    pub _dont_touch_that: [u8; 36usize],
}
#[test]
fn bindgen_test_layout_godot_basis() {
    assert_eq!(::std::mem::size_of::<godot_basis>() , 36usize , concat ! (
               "Size of: " , stringify ! ( godot_basis ) ));
    assert_eq! (::std::mem::align_of::<godot_basis>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_basis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_basis ) ) . _dont_touch_that as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_basis ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
extern "C" {
    pub fn godot_basis_new(p_basis: *mut godot_basis);
}
extern "C" {
    pub fn godot_basis_new_with_euler_quat(p_basis: *mut godot_basis,
                                           p_euler: *const godot_quat);
}
extern "C" {
    pub fn godot_basis_new_with_euler(p_basis: *mut godot_basis,
                                      p_euler: *const godot_vector3);
}
extern "C" {
    pub fn godot_basis_as_quat(p_basis: *const godot_basis) -> godot_quat;
}
extern "C" {
    pub fn godot_basis_get_euler(p_basis: *const godot_basis)
     -> godot_vector3;
}
extern "C" {
    pub fn godot_basis_get_elements(p_basis: *mut godot_basis,
                                    p_elements: *mut godot_vector3);
}
#[repr(C)]
pub struct godot_transform {
    pub _dont_touch_that: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_godot_transform() {
    assert_eq!(::std::mem::size_of::<godot_transform>() , 48usize , concat ! (
               "Size of: " , stringify ! ( godot_transform ) ));
    assert_eq! (::std::mem::align_of::<godot_transform>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( godot_transform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_transform ) ) . _dont_touch_that as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_transform ) ,
                "::" , stringify ! ( _dont_touch_that ) ));
}
extern "C" {
    pub fn godot_transform_new(p_trans: *mut godot_transform);
}
extern "C" {
    pub fn godot_transform_new_with_basis(p_trans: *mut godot_transform,
                                          p_basis: *const godot_basis);
}
extern "C" {
    pub fn godot_transform_new_with_basis_origin(p_trans:
                                                     *mut godot_transform,
                                                 p_basis: *const godot_basis,
                                                 p_origin:
                                                     *const godot_vector3);
}
extern "C" {
    pub fn godot_transform_get_basis(p_trans: *mut godot_transform)
     -> *mut godot_basis;
}
extern "C" {
    pub fn godot_transform_get_origin(p_trans: *mut godot_transform)
     -> *mut godot_vector3;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_color {
    pub _dont_touch_that: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_godot_color() {
    assert_eq!(::std::mem::size_of::<godot_color>() , 16usize , concat ! (
               "Size of: " , stringify ! ( godot_color ) ));
    assert_eq! (::std::mem::align_of::<godot_color>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_color ) ) . _dont_touch_that as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_color ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_color {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_color_new(p_color: *mut godot_color);
}
extern "C" {
    pub fn godot_color_new_rgba(p_color: *mut godot_color, r: godot_real,
                                g: godot_real, b: godot_real, a: godot_real);
}
extern "C" {
    pub fn godot_color_get_32(p_color: *const godot_color) -> u32;
}
extern "C" {
    pub fn godot_color_index(p_color: *mut godot_color, idx: godot_int)
     -> *mut f32;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_image {
    pub _dont_touch_that: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_godot_image() {
    assert_eq!(::std::mem::size_of::<godot_image>() , 32usize , concat ! (
               "Size of: " , stringify ! ( godot_image ) ));
    assert_eq! (::std::mem::align_of::<godot_image>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_image ) ) . _dont_touch_that as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_image ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_image {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_pool_byte_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_pool_byte_array() {
    assert_eq!(::std::mem::size_of::<godot_pool_byte_array>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( godot_pool_byte_array )
               ));
    assert_eq! (::std::mem::align_of::<godot_pool_byte_array>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_pool_byte_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_pool_byte_array ) ) .
                _dont_touch_that as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_pool_byte_array )
                , "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_pool_byte_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_pool_int_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_pool_int_array() {
    assert_eq!(::std::mem::size_of::<godot_pool_int_array>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( godot_pool_int_array ) ));
    assert_eq! (::std::mem::align_of::<godot_pool_int_array>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_pool_int_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_pool_int_array ) ) .
                _dont_touch_that as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_pool_int_array )
                , "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_pool_int_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_pool_real_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_pool_real_array() {
    assert_eq!(::std::mem::size_of::<godot_pool_real_array>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( godot_pool_real_array )
               ));
    assert_eq! (::std::mem::align_of::<godot_pool_real_array>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_pool_real_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_pool_real_array ) ) .
                _dont_touch_that as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_pool_real_array )
                , "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_pool_real_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_pool_string_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_pool_string_array() {
    assert_eq!(::std::mem::size_of::<godot_pool_string_array>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_pool_string_array ) ));
    assert_eq! (::std::mem::align_of::<godot_pool_string_array>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_pool_string_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_pool_string_array ) ) .
                _dont_touch_that as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_pool_string_array
                ) , "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_pool_string_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_pool_vector2_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_pool_vector2_array() {
    assert_eq!(::std::mem::size_of::<godot_pool_vector2_array>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_pool_vector2_array ) ));
    assert_eq! (::std::mem::align_of::<godot_pool_vector2_array>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_pool_vector2_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_pool_vector2_array ) ) .
                _dont_touch_that as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_pool_vector2_array ) , "::" , stringify ! (
                _dont_touch_that ) ));
}
impl Clone for godot_pool_vector2_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_pool_vector3_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_pool_vector3_array() {
    assert_eq!(::std::mem::size_of::<godot_pool_vector3_array>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_pool_vector3_array ) ));
    assert_eq! (::std::mem::align_of::<godot_pool_vector3_array>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_pool_vector3_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_pool_vector3_array ) ) .
                _dont_touch_that as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_pool_vector3_array ) , "::" , stringify ! (
                _dont_touch_that ) ));
}
impl Clone for godot_pool_vector3_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_pool_color_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_pool_color_array() {
    assert_eq!(::std::mem::size_of::<godot_pool_color_array>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( godot_pool_color_array )
               ));
    assert_eq! (::std::mem::align_of::<godot_pool_color_array>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_pool_color_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_pool_color_array ) ) .
                _dont_touch_that as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_pool_color_array
                ) , "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_pool_color_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_array() {
    assert_eq!(::std::mem::size_of::<godot_array>() , 8usize , concat ! (
               "Size of: " , stringify ! ( godot_array ) ));
    assert_eq! (::std::mem::align_of::<godot_array>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_array ) ) . _dont_touch_that as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_array ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_variant {
    pub _dont_touch_that: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_godot_variant() {
    assert_eq!(::std::mem::size_of::<godot_variant>() , 24usize , concat ! (
               "Size of: " , stringify ! ( godot_variant ) ));
    assert_eq! (::std::mem::align_of::<godot_variant>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_variant ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_variant ) ) . _dont_touch_that as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_variant ) , "::"
                , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_variant {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_dictionary {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_dictionary() {
    assert_eq!(::std::mem::size_of::<godot_dictionary>() , 8usize , concat ! (
               "Size of: " , stringify ! ( godot_dictionary ) ));
    assert_eq! (::std::mem::align_of::<godot_dictionary>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( godot_dictionary ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_dictionary ) ) . _dont_touch_that
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_dictionary ) ,
                "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_dictionary {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_dictionary_new(p_dict: *mut godot_dictionary);
}
extern "C" {
    pub fn godot_dictionary_clear(p_dict: *mut godot_dictionary);
}
extern "C" {
    pub fn godot_dictionary_empty(p_dict: *const godot_dictionary)
     -> godot_bool;
}
extern "C" {
    pub fn godot_dictionary_erase(p_dict: *mut godot_dictionary,
                                  p_key: *const godot_variant);
}
extern "C" {
    pub fn godot_dictionary_has(p_dict: *const godot_dictionary,
                                p_key: *const godot_variant) -> godot_bool;
}
extern "C" {
    pub fn godot_dictionary_has_all(p_dict: *const godot_dictionary,
                                    p_keys: *const godot_array) -> godot_bool;
}
extern "C" {
    pub fn godot_dictionary_hash(p_dict: *const godot_dictionary) -> u32;
}
extern "C" {
    pub fn godot_dictionary_keys(p_dict: *const godot_dictionary)
     -> godot_array;
}
extern "C" {
    pub fn godot_dictionary_parse_json(p_dict: *mut godot_dictionary,
                                       p_json: *const godot_string)
     -> godot_int;
}
extern "C" {
    pub fn godot_dictionary_operator_index(p_dict: *mut godot_dictionary,
                                           p_key: *const godot_variant)
     -> *mut godot_variant;
}
extern "C" {
    pub fn godot_dictionary_size(p_dict: *const godot_dictionary)
     -> godot_int;
}
extern "C" {
    pub fn godot_dictionary_to_json(p_dict: *const godot_dictionary)
     -> godot_string;
}
extern "C" {
    pub fn godot_dictionary_values(p_dict: *const godot_dictionary)
     -> godot_array;
}
extern "C" {
    pub fn godot_dictionary_destroy(p_dict: *mut godot_dictionary);
}
#[repr(C)]
pub struct godot_input_event {
    pub _dont_touch_that: [u8; 56usize],
}
#[test]
fn bindgen_test_layout_godot_input_event() {
    assert_eq!(::std::mem::size_of::<godot_input_event>() , 56usize , concat !
               ( "Size of: " , stringify ! ( godot_input_event ) ));
    assert_eq! (::std::mem::align_of::<godot_input_event>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( godot_input_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_input_event ) ) . _dont_touch_that
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_input_event ) ,
                "::" , stringify ! ( _dont_touch_that ) ));
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum godot_input_event_type {
    GODOT_INPUT_EVENT_TYPE_NONE = 0,
    GODOT_INPUT_EVENT_TYPE_KEY = 1,
    GODOT_INPUT_EVENT_TYPE_MOUSE_MOTION = 2,
    GODOT_INPUT_EVENT_TYPE_MOUSE_BUTTON = 3,
    GODOT_INPUT_EVENT_TYPE_JOYPAD_MOTION = 4,
    GODOT_INPUT_EVENT_TYPE_JOYPAD_BUTTON = 5,
    GODOT_INPUT_EVENT_TYPE_SCREEN_TOUCH = 6,
    GODOT_INPUT_EVENT_TYPE_SCREEN_DRAG = 7,
    GODOT_INPUT_EVENT_TYPE_ACTION = 8,
    GODOT_INPUT_EVENT_TYPE_TYPE_MAX = 9,
}
pub const GODOT_BUTTON_LEFT: _bindgen_ty_1 = _bindgen_ty_1::GODOT_BUTTON_LEFT;
pub const GODOT_BUTTON_RIGHT: _bindgen_ty_1 =
    _bindgen_ty_1::GODOT_BUTTON_RIGHT;
pub const GODOT_BUTTON_MIDDLE: _bindgen_ty_1 =
    _bindgen_ty_1::GODOT_BUTTON_MIDDLE;
pub const GODOT_BUTTON_WHEEL_UP: _bindgen_ty_1 =
    _bindgen_ty_1::GODOT_BUTTON_WHEEL_UP;
pub const GODOT_BUTTON_WHEEL_DOWN: _bindgen_ty_1 =
    _bindgen_ty_1::GODOT_BUTTON_WHEEL_DOWN;
pub const GODOT_BUTTON_WHEEL_LEFT: _bindgen_ty_1 =
    _bindgen_ty_1::GODOT_BUTTON_WHEEL_LEFT;
pub const GODOT_BUTTON_WHEEL_RIGHT: _bindgen_ty_1 =
    _bindgen_ty_1::GODOT_BUTTON_WHEEL_RIGHT;
pub const GODOT_BUTTON_MASK_LEFT: _bindgen_ty_1 =
    _bindgen_ty_1::GODOT_BUTTON_LEFT;
pub const GODOT_BUTTON_MASK_RIGHT: _bindgen_ty_1 =
    _bindgen_ty_1::GODOT_BUTTON_RIGHT;
pub const GODOT_BUTTON_MASK_MIDDLE: _bindgen_ty_1 =
    _bindgen_ty_1::GODOT_BUTTON_WHEEL_UP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    GODOT_BUTTON_LEFT = 1,
    GODOT_BUTTON_RIGHT = 2,
    GODOT_BUTTON_MIDDLE = 3,
    GODOT_BUTTON_WHEEL_UP = 4,
    GODOT_BUTTON_WHEEL_DOWN = 5,
    GODOT_BUTTON_WHEEL_LEFT = 6,
    GODOT_BUTTON_WHEEL_RIGHT = 7,
}
pub const GODOT_JOY_BUTTON_0: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_0;
pub const GODOT_JOY_BUTTON_1: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_1;
pub const GODOT_JOY_BUTTON_2: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_2;
pub const GODOT_JOY_BUTTON_3: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_3;
pub const GODOT_JOY_BUTTON_4: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_4;
pub const GODOT_JOY_BUTTON_5: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_5;
pub const GODOT_JOY_BUTTON_6: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_6;
pub const GODOT_JOY_BUTTON_7: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_7;
pub const GODOT_JOY_BUTTON_8: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_8;
pub const GODOT_JOY_BUTTON_9: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_9;
pub const GODOT_JOY_BUTTON_10: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_10;
pub const GODOT_JOY_BUTTON_11: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_11;
pub const GODOT_JOY_BUTTON_12: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_12;
pub const GODOT_JOY_BUTTON_13: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_13;
pub const GODOT_JOY_BUTTON_14: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_14;
pub const GODOT_JOY_BUTTON_15: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_15;
pub const GODOT_JOY_BUTTON_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_MAX;
pub const GODOT_JOY_L: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_4;
pub const GODOT_JOY_R: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_5;
pub const GODOT_JOY_L2: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_6;
pub const GODOT_JOY_R2: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_7;
pub const GODOT_JOY_L3: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_8;
pub const GODOT_JOY_R3: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_9;
pub const GODOT_JOY_SELECT: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_10;
pub const GODOT_JOY_START: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_11;
pub const GODOT_JOY_DPAD_UP: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_12;
pub const GODOT_JOY_DPAD_DOWN: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_13;
pub const GODOT_JOY_DPAD_LEFT: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_14;
pub const GODOT_JOY_DPAD_RIGHT: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_15;
pub const GODOT_JOY_SNES_B: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_0;
pub const GODOT_JOY_SNES_A: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_1;
pub const GODOT_JOY_SNES_Y: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_2;
pub const GODOT_JOY_SNES_X: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_3;
pub const GODOT_JOY_SONY_CIRCLE: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_1;
pub const GODOT_JOY_SONY_X: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_0;
pub const GODOT_JOY_SONY_SQUARE: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_2;
pub const GODOT_JOY_SONY_TRIANGLE: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_3;
pub const GODOT_JOY_SEGA_B: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_1;
pub const GODOT_JOY_SEGA_A: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_0;
pub const GODOT_JOY_SEGA_X: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_2;
pub const GODOT_JOY_SEGA_Y: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_3;
pub const GODOT_JOY_XBOX_B: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_1;
pub const GODOT_JOY_XBOX_A: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_0;
pub const GODOT_JOY_XBOX_X: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_2;
pub const GODOT_JOY_XBOX_Y: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_3;
pub const GODOT_JOY_DS_A: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_1;
pub const GODOT_JOY_DS_B: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_0;
pub const GODOT_JOY_DS_X: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_3;
pub const GODOT_JOY_DS_Y: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_2;
pub const GODOT_JOY_WII_C: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_5;
pub const GODOT_JOY_WII_Z: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_6;
pub const GODOT_JOY_WII_MINUS: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_9;
pub const GODOT_JOY_WII_PLUS: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_10;
pub const GODOT_JOY_AXIS_0: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_0;
pub const GODOT_JOY_AXIS_1: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_1;
pub const GODOT_JOY_AXIS_2: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_2;
pub const GODOT_JOY_AXIS_3: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_3;
pub const GODOT_JOY_AXIS_4: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_4;
pub const GODOT_JOY_AXIS_5: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_5;
pub const GODOT_JOY_AXIS_6: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_6;
pub const GODOT_JOY_AXIS_7: _bindgen_ty_2 = _bindgen_ty_2::GODOT_JOY_BUTTON_7;
pub const GODOT_JOY_AXIS_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_8;
pub const GODOT_JOY_ANALOG_0_X: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_0;
pub const GODOT_JOY_ANALOG_0_Y: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_1;
pub const GODOT_JOY_ANALOG_1_X: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_2;
pub const GODOT_JOY_ANALOG_1_Y: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_3;
pub const GODOT_JOY_ANALOG_2_X: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_4;
pub const GODOT_JOY_ANALOG_2_Y: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_5;
pub const GODOT_JOY_ANALOG_L2: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_6;
pub const GODOT_JOY_ANALOG_R2: _bindgen_ty_2 =
    _bindgen_ty_2::GODOT_JOY_BUTTON_7;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    GODOT_JOY_BUTTON_0 = 0,
    GODOT_JOY_BUTTON_1 = 1,
    GODOT_JOY_BUTTON_2 = 2,
    GODOT_JOY_BUTTON_3 = 3,
    GODOT_JOY_BUTTON_4 = 4,
    GODOT_JOY_BUTTON_5 = 5,
    GODOT_JOY_BUTTON_6 = 6,
    GODOT_JOY_BUTTON_7 = 7,
    GODOT_JOY_BUTTON_8 = 8,
    GODOT_JOY_BUTTON_9 = 9,
    GODOT_JOY_BUTTON_10 = 10,
    GODOT_JOY_BUTTON_11 = 11,
    GODOT_JOY_BUTTON_12 = 12,
    GODOT_JOY_BUTTON_13 = 13,
    GODOT_JOY_BUTTON_14 = 14,
    GODOT_JOY_BUTTON_15 = 15,
    GODOT_JOY_BUTTON_MAX = 16,
}
extern "C" {
    pub fn godot_input_event_new(p_ie: *mut godot_input_event);
}
extern "C" {
    pub fn godot_input_event_is_pressed(p_ie: *const godot_input_event)
     -> godot_bool;
}
extern "C" {
    pub fn godot_input_event_is_action(p_ie: *const godot_input_event,
                                       p_action: *const godot_string)
     -> godot_bool;
}
extern "C" {
    pub fn godot_input_event_is_action_pressed(p_ie: *const godot_input_event,
                                               p_action: *const godot_string)
     -> godot_bool;
}
extern "C" {
    pub fn godot_input_event_is_action_released(p_ie:
                                                    *const godot_input_event,
                                                p_action: *const godot_string)
     -> godot_bool;
}
extern "C" {
    pub fn godot_input_event_is_echo(p_ie: *const godot_input_event)
     -> godot_bool;
}
extern "C" {
    pub fn godot_input_event_set_as_action(p_ie: *mut godot_input_event,
                                           p_action: *const godot_string,
                                           p_pressed: godot_bool);
}
extern "C" {
    pub fn godot_input_event_as_string(p_ie: *const godot_input_event)
     -> godot_string;
}
extern "C" {
    pub fn godot_input_event_get_id(p_ie: *mut godot_input_event) -> *mut u32;
}
extern "C" {
    pub fn godot_input_event_get_type(p_ie: *mut godot_input_event)
     -> *mut godot_input_event_type;
}
extern "C" {
    pub fn godot_input_event_get_device(p_ie: *mut godot_input_event)
     -> *mut godot_int;
}
extern "C" {
    pub fn godot_input_event_mod_get_alt(p_event: *mut godot_input_event)
     -> *mut godot_bool;
}
extern "C" {
    pub fn godot_input_event_mod_get_ctrl(p_event: *mut godot_input_event)
     -> *mut godot_bool;
}
extern "C" {
    pub fn godot_input_event_mod_get_command(p_event: *mut godot_input_event)
     -> *mut godot_bool;
}
extern "C" {
    pub fn godot_input_event_mod_get_shift(p_event: *mut godot_input_event)
     -> *mut godot_bool;
}
extern "C" {
    pub fn godot_input_event_mod_get_meta(p_event: *mut godot_input_event)
     -> *mut godot_bool;
}
extern "C" {
    pub fn godot_input_event_key_get_scancode(p_event: *mut godot_input_event)
     -> *mut u32;
}
extern "C" {
    pub fn godot_input_event_key_get_unicode(p_event: *mut godot_input_event)
     -> *mut u32;
}
extern "C" {
    pub fn godot_input_event_key_get_pressed(p_event: *mut godot_input_event)
     -> *mut godot_bool;
}
extern "C" {
    pub fn godot_input_event_key_get_echo(p_event: *mut godot_input_event)
     -> *mut godot_bool;
}
extern "C" {
    pub fn godot_input_event_mouse_get_x(p_event: *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_mouse_get_y(p_event: *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_mouse_get_global_x(p_event:
                                                    *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_mouse_get_global_y(p_event:
                                                    *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_mouse_get_button_mask(p_event:
                                                       *mut godot_input_event)
     -> *mut godot_int;
}
extern "C" {
    pub fn godot_input_event_mouse_button_get_button_index(p_event:
                                                               *mut godot_input_event)
     -> *mut godot_int;
}
extern "C" {
    pub fn godot_input_event_mouse_button_get_pressed(p_event:
                                                          *mut godot_input_event)
     -> *mut godot_bool;
}
extern "C" {
    pub fn godot_input_event_mouse_button_get_doubleclick(p_event:
                                                              *mut godot_input_event)
     -> *mut godot_bool;
}
extern "C" {
    pub fn godot_input_event_mouse_motion_get_relative_x(p_event:
                                                             *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_mouse_motion_get_relative_y(p_event:
                                                             *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_mouse_motion_get_speed_x(p_event:
                                                          *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_mouse_motion_get_speed_y(p_event:
                                                          *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_joypad_motion_get_axis(p_event:
                                                        *mut godot_input_event)
     -> *mut godot_int;
}
extern "C" {
    pub fn godot_input_event_joypad_motion_get_axis_value(p_event:
                                                              *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_joypad_button_get_button_index(p_event:
                                                                *mut godot_input_event)
     -> *mut godot_int;
}
extern "C" {
    pub fn godot_input_event_joypad_button_get_pressed(p_event:
                                                           *mut godot_input_event)
     -> *mut godot_bool;
}
extern "C" {
    pub fn godot_input_event_joypad_button_get_pressure(p_event:
                                                            *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_screen_touch_get_index(p_event:
                                                        *mut godot_input_event)
     -> *mut godot_int;
}
extern "C" {
    pub fn godot_input_event_screen_touch_get_x(p_event:
                                                    *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_screen_touch_get_y(p_event:
                                                    *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_screen_touch_get_pressed(p_event:
                                                          *mut godot_input_event)
     -> *mut godot_bool;
}
extern "C" {
    pub fn godot_input_event_screen_drag_get_index(p_event:
                                                       *mut godot_input_event)
     -> *mut godot_int;
}
extern "C" {
    pub fn godot_input_event_screen_drag_get_x(p_event:
                                                   *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_screen_drag_get_y(p_event:
                                                   *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_screen_drag_get_relative_x(p_event:
                                                            *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_screen_drag_get_relative_y(p_event:
                                                            *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_screen_drag_get_speed_x(p_event:
                                                         *mut godot_input_event)
     -> *mut f32;
}
extern "C" {
    pub fn godot_input_event_screen_drag_get_speed_y(p_event:
                                                         *mut godot_input_event)
     -> *mut f32;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_node_path {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_node_path() {
    assert_eq!(::std::mem::size_of::<godot_node_path>() , 8usize , concat ! (
               "Size of: " , stringify ! ( godot_node_path ) ));
    assert_eq! (::std::mem::align_of::<godot_node_path>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( godot_node_path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_node_path ) ) . _dont_touch_that as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_node_path ) ,
                "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_node_path {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_node_path_new(p_np: *mut godot_node_path,
                               p_from: *const godot_string);
}
extern "C" {
    pub fn godot_node_path_copy(p_np: *mut godot_node_path,
                                p_from: *const godot_node_path);
}
extern "C" {
    pub fn godot_node_path_get_name(p_np: *const godot_node_path,
                                    p_idx: godot_int) -> godot_string;
}
extern "C" {
    pub fn godot_node_path_get_name_count(p_np: *const godot_node_path)
     -> godot_int;
}
extern "C" {
    pub fn godot_node_path_get_property(p_np: *const godot_node_path)
     -> godot_string;
}
extern "C" {
    pub fn godot_node_path_get_subname(p_np: *const godot_node_path,
                                       p_idx: godot_int) -> godot_string;
}
extern "C" {
    pub fn godot_node_path_get_subname_count(p_np: *const godot_node_path)
     -> godot_int;
}
extern "C" {
    pub fn godot_node_path_is_absolute(p_np: *const godot_node_path)
     -> godot_bool;
}
extern "C" {
    pub fn godot_node_path_is_empty(p_np: *const godot_node_path)
     -> godot_bool;
}
extern "C" {
    pub fn godot_node_path_as_string(p_np: *const godot_node_path)
     -> godot_string;
}
extern "C" {
    pub fn godot_node_path_destroy(p_np: *mut godot_node_path);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_rid {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_rid() {
    assert_eq!(::std::mem::size_of::<godot_rid>() , 8usize , concat ! (
               "Size of: " , stringify ! ( godot_rid ) ));
    assert_eq! (::std::mem::align_of::<godot_rid>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_rid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_rid ) ) . _dont_touch_that as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_rid ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_rid {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_rid_new(p_rid: *mut godot_rid, p_from: *mut godot_object);
}
extern "C" {
    pub fn godot_rid_get_rid(p_rid: *const godot_rid) -> u32;
}
extern "C" {
    pub fn godot_rid_destroy(p_rid: *mut godot_rid);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum godot_variant_type {
    GODOT_VARIANT_TYPE_NIL = 0,
    GODOT_VARIANT_TYPE_BOOL = 1,
    GODOT_VARIANT_TYPE_INT = 2,
    GODOT_VARIANT_TYPE_REAL = 3,
    GODOT_VARIANT_TYPE_STRING = 4,
    GODOT_VARIANT_TYPE_VECTOR2 = 5,
    GODOT_VARIANT_TYPE_RECT2 = 6,
    GODOT_VARIANT_TYPE_VECTOR3 = 7,
    GODOT_VARIANT_TYPE_TRANSFORM2D = 8,
    GODOT_VARIANT_TYPE_PLANE = 9,
    GODOT_VARIANT_TYPE_QUAT = 10,
    GODOT_VARIANT_TYPE_RECT3 = 11,
    GODOT_VARIANT_TYPE_BASIS = 12,
    GODOT_VARIANT_TYPE_TRANSFORM = 13,
    GODOT_VARIANT_TYPE_COLOR = 14,
    GODOT_VARIANT_TYPE_IMAGE = 15,
    GODOT_VARIANT_TYPE_NODE_PATH = 16,
    GODOT_VARIANT_TYPE_RID = 17,
    GODOT_VARIANT_TYPE_OBJECT = 18,
    GODOT_VARIANT_TYPE_INPUT_EVENT = 19,
    GODOT_VARIANT_TYPE_DICTIONARY = 20,
    GODOT_VARIANT_TYPE_ARRAY = 21,
    GODOT_VARIANT_TYPE_POOL_BYTE_ARRAY = 22,
    GODOT_VARIANT_TYPE_POOL_INT_ARRAY = 23,
    GODOT_VARIANT_TYPE_POOL_REAL_ARRAY = 24,
    GODOT_VARIANT_TYPE_POOL_STRING_ARRAY = 25,
    GODOT_VARIANT_TYPE_POOL_VECTOR2_ARRAY = 26,
    GODOT_VARIANT_TYPE_POOL_VECTOR3_ARRAY = 27,
    GODOT_VARIANT_TYPE_POOL_COLOR_ARRAY = 28,
}
extern "C" {
    pub fn godot_variant_get_type(p_v: *const godot_variant)
     -> godot_variant_type;
}
extern "C" {
    pub fn godot_variant_copy(p_dest: *mut godot_variant,
                              p_src: *const godot_variant);
}
extern "C" {
    pub fn godot_variant_new_nil(p_v: *mut godot_variant);
}
extern "C" {
    pub fn godot_variant_new_bool(p_v: *mut godot_variant, p_b: godot_bool);
}
extern "C" {
    pub fn godot_variant_new_uint(p_v: *mut godot_variant, p_i: u64);
}
extern "C" {
    pub fn godot_variant_new_int(p_v: *mut godot_variant, p_i: i64);
}
extern "C" {
    pub fn godot_variant_new_real(p_v: *mut godot_variant, p_r: f64);
}
extern "C" {
    pub fn godot_variant_new_string(p_v: *mut godot_variant,
                                    p_s: *const godot_string);
}
extern "C" {
    pub fn godot_variant_new_vector2(p_v: *mut godot_variant,
                                     p_v2: *const godot_vector2);
}
extern "C" {
    pub fn godot_variant_new_rect2(p_v: *mut godot_variant,
                                   p_rect2: *const godot_rect2);
}
extern "C" {
    pub fn godot_variant_new_vector3(p_v: *mut godot_variant,
                                     p_v3: *const godot_vector3);
}
extern "C" {
    pub fn godot_variant_new_transform2d(p_v: *mut godot_variant,
                                         p_t2d: *const godot_transform2d);
}
extern "C" {
    pub fn godot_variant_new_plane(p_v: *mut godot_variant,
                                   p_plane: *const godot_plane);
}
extern "C" {
    pub fn godot_variant_new_quat(p_v: *mut godot_variant,
                                  p_quat: *const godot_quat);
}
extern "C" {
    pub fn godot_variant_new_rect3(p_v: *mut godot_variant,
                                   p_rect3: *const godot_rect3);
}
extern "C" {
    pub fn godot_variant_new_basis(p_v: *mut godot_variant,
                                   p_basis: *const godot_basis);
}
extern "C" {
    pub fn godot_variant_new_transform(p_v: *mut godot_variant,
                                       p_trans: *const godot_transform);
}
extern "C" {
    pub fn godot_variant_new_color(p_v: *mut godot_variant,
                                   p_color: *const godot_color);
}
extern "C" {
    pub fn godot_variant_new_image(p_v: *mut godot_variant,
                                   p_img: *const godot_image);
}
extern "C" {
    pub fn godot_variant_new_node_path(p_v: *mut godot_variant,
                                       p_np: *const godot_node_path);
}
extern "C" {
    pub fn godot_variant_new_rid(p_v: *mut godot_variant,
                                 p_rid: *const godot_rid);
}
extern "C" {
    pub fn godot_variant_new_object(p_v: *mut godot_variant,
                                    p_obj: *const godot_object);
}
extern "C" {
    pub fn godot_variant_new_input_event(p_v: *mut godot_variant,
                                         p_event: *const godot_input_event);
}
extern "C" {
    pub fn godot_variant_new_dictionary(p_v: *mut godot_variant,
                                        p_dict: *const godot_dictionary);
}
extern "C" {
    pub fn godot_variant_new_array(p_v: *mut godot_variant,
                                   p_arr: *const godot_array);
}
extern "C" {
    pub fn godot_variant_new_pool_byte_array(p_v: *mut godot_variant,
                                             p_pba:
                                                 *const godot_pool_byte_array);
}
extern "C" {
    pub fn godot_variant_new_pool_int_array(p_v: *mut godot_variant,
                                            p_pia:
                                                *const godot_pool_int_array);
}
extern "C" {
    pub fn godot_variant_new_pool_real_array(p_v: *mut godot_variant,
                                             p_pra:
                                                 *const godot_pool_real_array);
}
extern "C" {
    pub fn godot_variant_new_pool_string_array(p_v: *mut godot_variant,
                                               p_psa:
                                                   *const godot_pool_string_array);
}
extern "C" {
    pub fn godot_variant_new_pool_vector2_array(p_v: *mut godot_variant,
                                                p_pv2a:
                                                    *const godot_pool_vector2_array);
}
extern "C" {
    pub fn godot_variant_new_pool_vector3_array(p_v: *mut godot_variant,
                                                p_pv3a:
                                                    *const godot_pool_vector3_array);
}
extern "C" {
    pub fn godot_variant_new_pool_color_array(p_v: *mut godot_variant,
                                              p_pca:
                                                  *const godot_pool_color_array);
}
extern "C" {
    pub fn godot_variant_as_bool(p_v: *const godot_variant) -> godot_bool;
}
extern "C" {
    pub fn godot_variant_as_uint(p_v: *const godot_variant) -> u64;
}
extern "C" {
    pub fn godot_variant_as_int(p_v: *const godot_variant) -> i64;
}
extern "C" {
    pub fn godot_variant_as_real(p_v: *const godot_variant) -> f64;
}
extern "C" {
    pub fn godot_variant_as_string(p_v: *const godot_variant) -> godot_string;
}
extern "C" {
    pub fn godot_variant_as_vector2(p_v: *const godot_variant)
     -> godot_vector2;
}
extern "C" {
    pub fn godot_variant_as_rect2(p_v: *const godot_variant) -> godot_rect2;
}
extern "C" {
    pub fn godot_variant_as_vector3(p_v: *const godot_variant)
     -> godot_vector3;
}
extern "C" {
    pub fn godot_variant_as_transform2d(p_v: *const godot_variant)
     -> godot_transform2d;
}
extern "C" {
    pub fn godot_variant_as_plane(p_v: *const godot_variant) -> godot_plane;
}
extern "C" {
    pub fn godot_variant_as_quat(p_v: *const godot_variant) -> godot_quat;
}
extern "C" {
    pub fn godot_variant_as_rect3(p_v: *const godot_variant) -> godot_rect3;
}
extern "C" {
    pub fn godot_variant_as_basis(p_v: *const godot_variant) -> godot_basis;
}
extern "C" {
    pub fn godot_variant_as_transform(p_v: *const godot_variant)
     -> godot_transform;
}
extern "C" {
    pub fn godot_variant_as_color(p_v: *const godot_variant) -> godot_color;
}
extern "C" {
    pub fn godot_variant_as_image(p_v: *const godot_variant) -> godot_image;
}
extern "C" {
    pub fn godot_variant_as_node_path(p_v: *const godot_variant)
     -> godot_node_path;
}
extern "C" {
    pub fn godot_variant_as_rid(p_v: *const godot_variant) -> godot_rid;
}
extern "C" {
    pub fn godot_variant_as_object(p_v: *const godot_variant)
     -> *mut godot_object;
}
extern "C" {
    pub fn godot_variant_as_input_event(p_v: *const godot_variant)
     -> godot_input_event;
}
extern "C" {
    pub fn godot_variant_as_dictionary(p_v: *const godot_variant)
     -> godot_dictionary;
}
extern "C" {
    pub fn godot_variant_as_array(p_v: *const godot_variant) -> godot_array;
}
extern "C" {
    pub fn godot_variant_as_pool_byte_array(p_v: *const godot_variant)
     -> godot_pool_byte_array;
}
extern "C" {
    pub fn godot_variant_as_pool_int_array(p_v: *const godot_variant)
     -> godot_pool_int_array;
}
extern "C" {
    pub fn godot_variant_as_pool_real_array(p_v: *const godot_variant)
     -> godot_pool_real_array;
}
extern "C" {
    pub fn godot_variant_as_pool_string_array(p_v: *const godot_variant)
     -> godot_pool_string_array;
}
extern "C" {
    pub fn godot_variant_as_pool_vector2_array(p_v: *const godot_variant)
     -> godot_pool_vector2_array;
}
extern "C" {
    pub fn godot_variant_as_pool_vector3_array(p_v: *const godot_variant)
     -> godot_pool_vector3_array;
}
extern "C" {
    pub fn godot_variant_as_pool_color_array(p_v: *const godot_variant)
     -> godot_pool_color_array;
}
extern "C" {
    pub fn godot_variant_call(p_v: *mut godot_variant,
                              p_method: *const godot_string,
                              p_args: *mut *const godot_variant,
                              p_argcount: godot_int) -> godot_variant;
}
extern "C" {
    pub fn godot_variant_has_method(p_v: *mut godot_variant,
                                    p_method: *const godot_string)
     -> godot_bool;
}
extern "C" {
    pub fn godot_variant_operator_equal(p_a: *const godot_variant,
                                        p_b: *const godot_variant)
     -> godot_bool;
}
extern "C" {
    pub fn godot_variant_operator_less(p_a: *const godot_variant,
                                       p_b: *const godot_variant)
     -> godot_bool;
}
extern "C" {
    pub fn godot_variant_hash_compare(p_a: *const godot_variant,
                                      p_b: *const godot_variant)
     -> godot_bool;
}
extern "C" {
    pub fn godot_variant_booleanize(p_v: *const godot_variant,
                                    p_valid: *mut godot_bool) -> godot_bool;
}
extern "C" {
    pub fn godot_variant_destroy(p_v: *mut godot_variant);
}
extern "C" {
    pub fn godot_array_new(p_arr: *mut godot_array);
}
extern "C" {
    pub fn godot_array_new_pool_color_array(p_arr: *mut godot_array,
                                            p_pca:
                                                *const godot_pool_color_array);
}
extern "C" {
    pub fn godot_array_new_pool_vector3_array(p_arr: *mut godot_array,
                                              p_pv3a:
                                                  *const godot_pool_vector3_array);
}
extern "C" {
    pub fn godot_array_new_pool_vector2_array(p_arr: *mut godot_array,
                                              p_pv2a:
                                                  *const godot_pool_vector2_array);
}
extern "C" {
    pub fn godot_array_new_pool_string_array(p_arr: *mut godot_array,
                                             p_psa:
                                                 *const godot_pool_string_array);
}
extern "C" {
    pub fn godot_array_new_pool_real_array(p_arr: *mut godot_array,
                                           p_pra:
                                               *const godot_pool_real_array);
}
extern "C" {
    pub fn godot_array_new_pool_int_array(p_arr: *mut godot_array,
                                          p_pia: *const godot_pool_int_array);
}
extern "C" {
    pub fn godot_array_new_pool_byte_array(p_arr: *mut godot_array,
                                           p_pba:
                                               *const godot_pool_byte_array);
}
extern "C" {
    pub fn godot_array_set(p_arr: *mut godot_array, p_idx: godot_int,
                           p_value: *const godot_variant);
}
extern "C" {
    pub fn godot_array_get(p_arr: *mut godot_array, p_idx: godot_int)
     -> *mut godot_variant;
}
extern "C" {
    pub fn godot_array_append(p_arr: *mut godot_array,
                              p_value: *const godot_variant);
}
extern "C" {
    pub fn godot_array_clear(p_arr: *mut godot_array);
}
extern "C" {
    pub fn godot_array_count(p_arr: *mut godot_array,
                             p_value: *const godot_variant) -> godot_int;
}
extern "C" {
    pub fn godot_array_empty(p_arr: *const godot_array) -> godot_bool;
}
extern "C" {
    pub fn godot_array_erase(p_arr: *mut godot_array,
                             p_value: *const godot_variant);
}
extern "C" {
    pub fn godot_array_front(p_arr: *const godot_array) -> godot_variant;
}
extern "C" {
    pub fn godot_array_back(p_arr: *const godot_array) -> godot_variant;
}
extern "C" {
    pub fn godot_array_find(p_arr: *const godot_array,
                            p_what: *const godot_variant, p_from: godot_int)
     -> godot_int;
}
extern "C" {
    pub fn godot_array_find_last(p_arr: *const godot_array,
                                 p_what: *const godot_variant) -> godot_int;
}
extern "C" {
    pub fn godot_array_has(p_arr: *const godot_array,
                           p_value: *const godot_variant) -> godot_bool;
}
extern "C" {
    pub fn godot_array_hash(p_arr: *const godot_array) -> u32;
}
extern "C" {
    pub fn godot_array_insert(p_arr: *mut godot_array, p_pos: godot_int,
                              p_value: *const godot_variant);
}
extern "C" {
    pub fn godot_array_invert(p_arr: *mut godot_array);
}
extern "C" {
    pub fn godot_array_is_shared(p_arr: *const godot_array) -> godot_bool;
}
extern "C" {
    pub fn godot_array_pop_back(p_arr: *mut godot_array) -> godot_variant;
}
extern "C" {
    pub fn godot_array_pop_front(p_arr: *mut godot_array) -> godot_variant;
}
extern "C" {
    pub fn godot_array_push_back(p_arr: *mut godot_array,
                                 p_value: *const godot_variant);
}
extern "C" {
    pub fn godot_array_push_front(p_arr: *mut godot_array,
                                  p_value: *const godot_variant);
}
extern "C" {
    pub fn godot_array_remove(p_arr: *mut godot_array, p_idx: godot_int);
}
extern "C" {
    pub fn godot_array_resize(p_arr: *mut godot_array, p_size: godot_int);
}
extern "C" {
    pub fn godot_array_rfind(p_arr: *const godot_array,
                             p_what: *const godot_variant, p_from: godot_int)
     -> godot_int;
}
extern "C" {
    pub fn godot_array_size(p_arr: *const godot_array) -> godot_int;
}
extern "C" {
    pub fn godot_array_sort(p_arr: *mut godot_array);
}
extern "C" {
    pub fn godot_array_sort_custom(p_arr: *mut godot_array,
                                   p_obj: *mut godot_object,
                                   p_func: *const godot_string);
}
extern "C" {
    pub fn godot_array_destroy(p_arr: *mut godot_array);
}
extern "C" {
    pub fn godot_pool_byte_array_new(p_pba: *mut godot_pool_byte_array);
}
extern "C" {
    pub fn godot_pool_byte_array_new_with_array(p_pba:
                                                    *mut godot_pool_byte_array,
                                                p_a: *const godot_array);
}
extern "C" {
    pub fn godot_pool_byte_array_append(p_pba: *mut godot_pool_byte_array,
                                        p_data: u8);
}
extern "C" {
    pub fn godot_pool_byte_array_append_array(p_pba:
                                                  *mut godot_pool_byte_array,
                                              p_array:
                                                  *const godot_pool_byte_array);
}
extern "C" {
    pub fn godot_pool_byte_array_insert(p_pba: *mut godot_pool_byte_array,
                                        p_idx: godot_int, p_data: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn godot_pool_byte_array_invert(p_pba: *mut godot_pool_byte_array);
}
extern "C" {
    pub fn godot_pool_byte_array_push_back(p_pba: *mut godot_pool_byte_array,
                                           p_data: u8);
}
extern "C" {
    pub fn godot_pool_byte_array_remove(p_pba: *mut godot_pool_byte_array,
                                        p_idx: godot_int);
}
extern "C" {
    pub fn godot_pool_byte_array_resize(p_pba: *mut godot_pool_byte_array,
                                        p_size: godot_int);
}
extern "C" {
    pub fn godot_pool_byte_array_set(p_pba: *mut godot_pool_byte_array,
                                     p_idx: godot_int, p_data: u8);
}
extern "C" {
    pub fn godot_pool_byte_array_get(p_pba: *mut godot_pool_byte_array,
                                     p_idx: godot_int) -> u8;
}
extern "C" {
    pub fn godot_pool_byte_array_size(p_pba: *mut godot_pool_byte_array)
     -> godot_int;
}
extern "C" {
    pub fn godot_pool_byte_array_destroy(p_pba: *mut godot_pool_byte_array);
}
extern "C" {
    pub fn godot_pool_int_array_new(p_pia: *mut godot_pool_int_array);
}
extern "C" {
    pub fn godot_pool_int_array_new_with_array(p_pia:
                                                   *mut godot_pool_int_array,
                                               p_a: *const godot_array);
}
extern "C" {
    pub fn godot_pool_int_array_append(p_pia: *mut godot_pool_int_array,
                                       p_data: godot_int);
}
extern "C" {
    pub fn godot_pool_int_array_append_array(p_pia: *mut godot_pool_int_array,
                                             p_array:
                                                 *const godot_pool_int_array);
}
extern "C" {
    pub fn godot_pool_int_array_insert(p_pia: *mut godot_pool_int_array,
                                       p_idx: godot_int, p_data: godot_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn godot_pool_int_array_invert(p_pia: *mut godot_pool_int_array);
}
extern "C" {
    pub fn godot_pool_int_array_push_back(p_pia: *mut godot_pool_int_array,
                                          p_data: godot_int);
}
extern "C" {
    pub fn godot_pool_int_array_remove(p_pia: *mut godot_pool_int_array,
                                       p_idx: godot_int);
}
extern "C" {
    pub fn godot_pool_int_array_resize(p_pia: *mut godot_pool_int_array,
                                       p_size: godot_int);
}
extern "C" {
    pub fn godot_pool_int_array_set(p_pia: *mut godot_pool_int_array,
                                    p_idx: godot_int, p_data: godot_int);
}
extern "C" {
    pub fn godot_pool_int_array_get(p_pia: *mut godot_pool_int_array,
                                    p_idx: godot_int) -> godot_int;
}
extern "C" {
    pub fn godot_pool_int_array_size(p_pia: *mut godot_pool_int_array)
     -> godot_int;
}
extern "C" {
    pub fn godot_pool_int_array_destroy(p_pia: *mut godot_pool_int_array);
}
extern "C" {
    pub fn godot_pool_real_array_new(p_pra: *mut godot_pool_real_array);
}
extern "C" {
    pub fn godot_pool_real_array_new_with_array(p_pra:
                                                    *mut godot_pool_real_array,
                                                p_a: *const godot_array);
}
extern "C" {
    pub fn godot_pool_real_array_append(p_pra: *mut godot_pool_real_array,
                                        p_data: godot_real);
}
extern "C" {
    pub fn godot_pool_real_array_append_array(p_pra:
                                                  *mut godot_pool_real_array,
                                              p_array:
                                                  *const godot_pool_real_array);
}
extern "C" {
    pub fn godot_pool_real_array_insert(p_pra: *mut godot_pool_real_array,
                                        p_idx: godot_int, p_data: godot_real)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn godot_pool_real_array_invert(p_pra: *mut godot_pool_real_array);
}
extern "C" {
    pub fn godot_pool_real_array_push_back(p_pra: *mut godot_pool_real_array,
                                           p_data: godot_real);
}
extern "C" {
    pub fn godot_pool_real_array_remove(p_pra: *mut godot_pool_real_array,
                                        p_idx: godot_int);
}
extern "C" {
    pub fn godot_pool_real_array_resize(p_pra: *mut godot_pool_real_array,
                                        p_size: godot_int);
}
extern "C" {
    pub fn godot_pool_real_array_set(p_pra: *mut godot_pool_real_array,
                                     p_idx: godot_int, p_data: godot_real);
}
extern "C" {
    pub fn godot_pool_real_array_get(p_pra: *mut godot_pool_real_array,
                                     p_idx: godot_int) -> godot_real;
}
extern "C" {
    pub fn godot_pool_real_array_size(p_pra: *mut godot_pool_real_array)
     -> godot_int;
}
extern "C" {
    pub fn godot_pool_real_array_destroy(p_pra: *mut godot_pool_real_array);
}
extern "C" {
    pub fn godot_pool_string_array_new(p_psa: *mut godot_pool_string_array);
}
extern "C" {
    pub fn godot_pool_string_array_new_with_array(p_psa:
                                                      *mut godot_pool_string_array,
                                                  p_a: *const godot_array);
}
extern "C" {
    pub fn godot_pool_string_array_append(p_psa: *mut godot_pool_string_array,
                                          p_data: *const godot_string);
}
extern "C" {
    pub fn godot_pool_string_array_append_array(p_psa:
                                                    *mut godot_pool_string_array,
                                                p_array:
                                                    *const godot_pool_string_array);
}
extern "C" {
    pub fn godot_pool_string_array_insert(p_psa: *mut godot_pool_string_array,
                                          p_idx: godot_int,
                                          p_data: *const godot_string)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn godot_pool_string_array_invert(p_psa:
                                              *mut godot_pool_string_array);
}
extern "C" {
    pub fn godot_pool_string_array_push_back(p_psa:
                                                 *mut godot_pool_string_array,
                                             p_data: *const godot_string);
}
extern "C" {
    pub fn godot_pool_string_array_remove(p_psa: *mut godot_pool_string_array,
                                          p_idx: godot_int);
}
extern "C" {
    pub fn godot_pool_string_array_resize(p_psa: *mut godot_pool_string_array,
                                          p_size: godot_int);
}
extern "C" {
    pub fn godot_pool_string_array_set(p_psa: *mut godot_pool_string_array,
                                       p_idx: godot_int,
                                       p_data: *const godot_string);
}
extern "C" {
    pub fn godot_pool_string_array_get(p_psa: *mut godot_pool_string_array,
                                       p_idx: godot_int) -> godot_string;
}
extern "C" {
    pub fn godot_pool_string_array_size(p_psa: *mut godot_pool_string_array)
     -> godot_int;
}
extern "C" {
    pub fn godot_pool_string_array_destroy(p_psa:
                                               *mut godot_pool_string_array);
}
extern "C" {
    pub fn godot_pool_vector2_array_new(p_pv2a:
                                            *mut godot_pool_vector2_array);
}
extern "C" {
    pub fn godot_pool_vector2_array_new_with_array(p_pv2a:
                                                       *mut godot_pool_vector2_array,
                                                   p_a: *const godot_array);
}
extern "C" {
    pub fn godot_pool_vector2_array_append(p_pv2a:
                                               *mut godot_pool_vector2_array,
                                           p_data: *const godot_vector2);
}
extern "C" {
    pub fn godot_pool_vector2_array_append_array(p_pv2a:
                                                     *mut godot_pool_vector2_array,
                                                 p_array:
                                                     *const godot_pool_vector2_array);
}
extern "C" {
    pub fn godot_pool_vector2_array_insert(p_pv2a:
                                               *mut godot_pool_vector2_array,
                                           p_idx: godot_int,
                                           p_data: *const godot_vector2)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn godot_pool_vector2_array_invert(p_pv2a:
                                               *mut godot_pool_vector2_array);
}
extern "C" {
    pub fn godot_pool_vector2_array_push_back(p_pv2a:
                                                  *mut godot_pool_vector2_array,
                                              p_data: *const godot_vector2);
}
extern "C" {
    pub fn godot_pool_vector2_array_remove(p_pv2a:
                                               *mut godot_pool_vector2_array,
                                           p_idx: godot_int);
}
extern "C" {
    pub fn godot_pool_vector2_array_resize(p_pv2a:
                                               *mut godot_pool_vector2_array,
                                           p_size: godot_int);
}
extern "C" {
    pub fn godot_pool_vector2_array_set(p_pv2a: *mut godot_pool_vector2_array,
                                        p_idx: godot_int,
                                        p_data: *const godot_vector2);
}
extern "C" {
    pub fn godot_pool_vector2_array_get(p_pv2a: *mut godot_pool_vector2_array,
                                        p_idx: godot_int) -> godot_vector2;
}
extern "C" {
    pub fn godot_pool_vector2_array_size(p_pv2a:
                                             *mut godot_pool_vector2_array)
     -> godot_int;
}
extern "C" {
    pub fn godot_pool_vector2_array_destroy(p_pv2a:
                                                *mut godot_pool_vector2_array);
}
extern "C" {
    pub fn godot_pool_vector3_array_new(p_pv3a:
                                            *mut godot_pool_vector3_array);
}
extern "C" {
    pub fn godot_pool_vector3_array_new_with_array(p_pv3a:
                                                       *mut godot_pool_vector3_array,
                                                   p_a: *const godot_array);
}
extern "C" {
    pub fn godot_pool_vector3_array_append(p_pv3a:
                                               *mut godot_pool_vector3_array,
                                           p_data: *const godot_vector3);
}
extern "C" {
    pub fn godot_pool_vector3_array_append_array(p_pv3a:
                                                     *mut godot_pool_vector3_array,
                                                 p_array:
                                                     *const godot_pool_vector3_array);
}
extern "C" {
    pub fn godot_pool_vector3_array_insert(p_pv3a:
                                               *mut godot_pool_vector3_array,
                                           p_idx: godot_int,
                                           p_data: *const godot_vector3)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn godot_pool_vector3_array_invert(p_pv3a:
                                               *mut godot_pool_vector3_array);
}
extern "C" {
    pub fn godot_pool_vector3_array_push_back(p_pv3a:
                                                  *mut godot_pool_vector3_array,
                                              p_data: *const godot_vector3);
}
extern "C" {
    pub fn godot_pool_vector3_array_remove(p_pv3a:
                                               *mut godot_pool_vector3_array,
                                           p_idx: godot_int);
}
extern "C" {
    pub fn godot_pool_vector3_array_resize(p_pv3a:
                                               *mut godot_pool_vector3_array,
                                           p_size: godot_int);
}
extern "C" {
    pub fn godot_pool_vector3_array_set(p_pv3a: *mut godot_pool_vector3_array,
                                        p_idx: godot_int,
                                        p_data: *const godot_vector3);
}
extern "C" {
    pub fn godot_pool_vector3_array_get(p_pv3a: *mut godot_pool_vector3_array,
                                        p_idx: godot_int) -> godot_vector3;
}
extern "C" {
    pub fn godot_pool_vector3_array_size(p_pv3a:
                                             *mut godot_pool_vector3_array)
     -> godot_int;
}
extern "C" {
    pub fn godot_pool_vector3_array_destroy(p_pv3a:
                                                *mut godot_pool_vector3_array);
}
extern "C" {
    pub fn godot_pool_color_array_new(p_pca: *mut godot_pool_color_array);
}
extern "C" {
    pub fn godot_pool_color_array_new_with_array(p_pca:
                                                     *mut godot_pool_color_array,
                                                 p_a: *const godot_array);
}
extern "C" {
    pub fn godot_pool_color_array_append(p_pca: *mut godot_pool_color_array,
                                         p_data: *const godot_color);
}
extern "C" {
    pub fn godot_pool_color_array_append_array(p_pca:
                                                   *mut godot_pool_color_array,
                                               p_array:
                                                   *const godot_pool_color_array);
}
extern "C" {
    pub fn godot_pool_color_array_insert(p_pca: *mut godot_pool_color_array,
                                         p_idx: godot_int,
                                         p_data: *const godot_color)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn godot_pool_color_array_invert(p_pca: *mut godot_pool_color_array);
}
extern "C" {
    pub fn godot_pool_color_array_push_back(p_pca:
                                                *mut godot_pool_color_array,
                                            p_data: *const godot_color);
}
extern "C" {
    pub fn godot_pool_color_array_remove(p_pca: *mut godot_pool_color_array,
                                         p_idx: godot_int);
}
extern "C" {
    pub fn godot_pool_color_array_resize(p_pca: *mut godot_pool_color_array,
                                         p_size: godot_int);
}
extern "C" {
    pub fn godot_pool_color_array_set(p_pca: *mut godot_pool_color_array,
                                      p_idx: godot_int,
                                      p_data: *const godot_color);
}
extern "C" {
    pub fn godot_pool_color_array_get(p_pca: *mut godot_pool_color_array,
                                      p_idx: godot_int) -> godot_color;
}
extern "C" {
    pub fn godot_pool_color_array_size(p_pca: *mut godot_pool_color_array)
     -> godot_int;
}
extern "C" {
    pub fn godot_pool_color_array_destroy(p_pca: *mut godot_pool_color_array);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum godot_image_format {
    GODOT_IMAGE_FORMAT_L8 = 0,
    GODOT_IMAGE_FORMAT_LA8 = 1,
    GODOT_IMAGE_FORMAT_R8 = 2,
    GODOT_IMAGE_FORMAT_RG8 = 3,
    GODOT_IMAGE_FORMAT_RGB8 = 4,
    GODOT_IMAGE_FORMAT_RGBA8 = 5,
    GODOT_IMAGE_FORMAT_RGB565 = 6,
    GODOT_IMAGE_FORMAT_RGBA4444 = 7,
    GODOT_IMAGE_FORMAT_RGBA5551 = 8,
    GODOT_IMAGE_FORMAT_RF = 9,
    GODOT_IMAGE_FORMAT_RGF = 10,
    GODOT_IMAGE_FORMAT_RGBF = 11,
    GODOT_IMAGE_FORMAT_RGBAF = 12,
    GODOT_IMAGE_FORMAT_RH = 13,
    GODOT_IMAGE_FORMAT_RGH = 14,
    GODOT_IMAGE_FORMAT_RGBH = 15,
    GODOT_IMAGE_FORMAT_RGBAH = 16,
    GODOT_IMAGE_FORMAT_DXT1 = 17,
    GODOT_IMAGE_FORMAT_DXT3 = 18,
    GODOT_IMAGE_FORMAT_DXT5 = 19,
    GODOT_IMAGE_FORMAT_ATI1 = 20,
    GODOT_IMAGE_FORMAT_ATI2 = 21,
    GODOT_IMAGE_FORMAT_BPTC_RGBA = 22,
    GODOT_IMAGE_FORMAT_BPTC_RGBF = 23,
    GODOT_IMAGE_FORMAT_BPTC_RGBFU = 24,
    GODOT_IMAGE_FORMAT_PVRTC2 = 25,
    GODOT_IMAGE_FORMAT_PVRTC2A = 26,
    GODOT_IMAGE_FORMAT_PVRTC4 = 27,
    GODOT_IMAGE_FORMAT_PVRTC4A = 28,
    GODOT_IMAGE_FORMAT_ETC = 29,
    GODOT_IMAGE_FORMAT_ETC2_R11 = 30,
    GODOT_IMAGE_FORMAT_ETC2_R11S = 31,
    GODOT_IMAGE_FORMAT_ETC2_RG11 = 32,
    GODOT_IMAGE_FORMAT_ETC2_RG11S = 33,
    GODOT_IMAGE_FORMAT_ETC2_RGB8 = 34,
    GODOT_IMAGE_FORMAT_ETC2_RGBA8 = 35,
    GODOT_IMAGE_FORMAT_ETC2_RGB8A1 = 36,
    GODOT_IMAGE_FORMAT_MAX = 37,
}
extern "C" {
    pub fn godot_image_new(p_img: *mut godot_image);
}
extern "C" {
    pub fn godot_image_new_with_png_jpg(p_img: *mut godot_image,
                                        p_mem_png_jpg: *const u8,
                                        p_len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn godot_image_new_with_xpm(p_img: *mut godot_image,
                                    p_xpm:
                                        *mut *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn godot_image_new_with_size_format(p_img: *mut godot_image,
                                            p_width: ::std::os::raw::c_int,
                                            p_height: ::std::os::raw::c_int,
                                            p_use_mipmaps: bool,
                                            p_format: godot_image_format);
}
extern "C" {
    pub fn godot_image_new_with_size_format_data(p_img: *mut godot_image,
                                                 p_width:
                                                     ::std::os::raw::c_int,
                                                 p_height:
                                                     ::std::os::raw::c_int,
                                                 p_use_mipmaps: bool,
                                                 p_format: godot_image_format,
                                                 p_data:
                                                     *mut godot_pool_byte_array);
}
extern "C" {
    pub fn godot_image_get_data(p_img: *mut godot_image)
     -> godot_pool_byte_array;
}
extern "C" {
    pub fn godot_image_load(p_img: *mut godot_image,
                            p_path: *const godot_string) -> godot_error;
}
extern "C" {
    pub fn godot_image_save_png(p_img: *mut godot_image,
                                p_path: *const godot_string) -> godot_error;
}
extern "C" {
    pub fn godot_image_get_width(p_img: *const godot_image)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn godot_image_get_height(p_img: *const godot_image)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn godot_image_has_mipmaps(p_img: *const godot_image) -> godot_bool;
}
extern "C" {
    pub fn godot_image_get_mipmap_count(p_img: *const godot_image)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn godot_image_destroy(p_img: *mut godot_image);
}
extern "C" {
    pub fn godot_object_destroy(p_o: *mut godot_object);
}
extern "C" {
    ////// Singleton API
    pub fn godot_global_get_singleton(p_name: *mut ::std::os::raw::c_char)
     -> *mut godot_object;
}
////// MethodBind API
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_method_bind {
    pub _dont_touch_that: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_godot_method_bind() {
    assert_eq!(::std::mem::size_of::<godot_method_bind>() , 1usize , concat !
               ( "Size of: " , stringify ! ( godot_method_bind ) ));
    assert_eq! (::std::mem::align_of::<godot_method_bind>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( godot_method_bind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_method_bind ) ) . _dont_touch_that
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_method_bind ) ,
                "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_method_bind {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_method_bind_get_method(p_classname:
                                            *const ::std::os::raw::c_char,
                                        p_methodname:
                                            *const ::std::os::raw::c_char)
     -> *mut godot_method_bind;
}
extern "C" {
    pub fn godot_method_bind_ptrcall(p_method_bind: *mut godot_method_bind,
                                     p_instance: *mut godot_object,
                                     p_args:
                                         *mut *const ::std::os::raw::c_void,
                                     p_ret: *mut ::std::os::raw::c_void);
}
////// Script API
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_native_init_options {
    pub in_editor: godot_bool,
    pub core_api_hash: u64,
    pub editor_api_hash: u64,
    pub no_api_hash: u64,
}
#[test]
fn bindgen_test_layout_godot_native_init_options() {
    assert_eq!(::std::mem::size_of::<godot_native_init_options>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_native_init_options ) ));
    assert_eq! (::std::mem::align_of::<godot_native_init_options>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_native_init_options )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_native_init_options ) ) . in_editor
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_native_init_options ) , "::" , stringify ! ( in_editor )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_native_init_options ) ) .
                core_api_hash as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_native_init_options ) , "::" , stringify ! (
                core_api_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_native_init_options ) ) .
                editor_api_hash as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_native_init_options ) , "::" , stringify ! (
                editor_api_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_native_init_options ) ) .
                no_api_hash as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_native_init_options ) , "::" , stringify ! ( no_api_hash
                ) ));
}
impl Clone for godot_native_init_options {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_native_terminate_options {
    pub in_editor: godot_bool,
}
#[test]
fn bindgen_test_layout_godot_native_terminate_options() {
    assert_eq!(::std::mem::size_of::<godot_native_terminate_options>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( godot_native_terminate_options )
               ));
    assert_eq! (::std::mem::align_of::<godot_native_terminate_options>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( godot_native_terminate_options
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_native_terminate_options ) ) .
                in_editor as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_native_terminate_options ) , "::" , stringify ! (
                in_editor ) ));
}
impl Clone for godot_native_terminate_options {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum godot_method_rpc_mode {
    GODOT_METHOD_RPC_MODE_DISABLED = 0,
    GODOT_METHOD_RPC_MODE_REMOTE = 1,
    GODOT_METHOD_RPC_MODE_SYNC = 2,
    GODOT_METHOD_RPC_MODE_MASTER = 3,
    GODOT_METHOD_RPC_MODE_SLAVE = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_method_attributes {
    pub rpc_type: godot_method_rpc_mode,
}
#[test]
fn bindgen_test_layout_godot_method_attributes() {
    assert_eq!(::std::mem::size_of::<godot_method_attributes>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_method_attributes ) ));
    assert_eq! (::std::mem::align_of::<godot_method_attributes>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_method_attributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_method_attributes ) ) . rpc_type as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_method_attributes
                ) , "::" , stringify ! ( rpc_type ) ));
}
impl Clone for godot_method_attributes {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum godot_property_hint {
    GODOT_PROPERTY_HINT_NONE = 0,
    GODOT_PROPERTY_HINT_RANGE = 1,
    GODOT_PROPERTY_HINT_EXP_RANGE = 2,
    GODOT_PROPERTY_HINT_ENUM = 3,
    GODOT_PROPERTY_HINT_EXP_EASING = 4,
    GODOT_PROPERTY_HINT_LENGTH = 5,
    GODOT_PROPERTY_HINT_SPRITE_FRAME = 6,
    GODOT_PROPERTY_HINT_KEY_ACCEL = 7,
    GODOT_PROPERTY_HINT_FLAGS = 8,
    GODOT_PROPERTY_HINT_LAYERS_2D_RENDER = 9,
    GODOT_PROPERTY_HINT_LAYERS_2D_PHYSICS = 10,
    GODOT_PROPERTY_HINT_LAYERS_3D_RENDER = 11,
    GODOT_PROPERTY_HINT_LAYERS_3D_PHYSICS = 12,
    GODOT_PROPERTY_HINT_FILE = 13,
    GODOT_PROPERTY_HINT_DIR = 14,
    GODOT_PROPERTY_HINT_GLOBAL_FILE = 15,
    GODOT_PROPERTY_HINT_GLOBAL_DIR = 16,
    GODOT_PROPERTY_HINT_RESOURCE_TYPE = 17,
    GODOT_PROPERTY_HINT_MULTILINE_TEXT = 18,
    GODOT_PROPERTY_HINT_COLOR_NO_ALPHA = 19,
    GODOT_PROPERTY_HINT_IMAGE_COMPRESS_LOSSY = 20,
    GODOT_PROPERTY_HINT_IMAGE_COMPRESS_LOSSLESS = 21,
    GODOT_PROPERTY_HINT_OBJECT_ID = 22,
    GODOT_PROPERTY_HINT_TYPE_STRING = 23,
    GODOT_PROPERTY_HINT_NODE_PATH_TO_EDITED_NODE = 24,
    GODOT_PROPERTY_HINT_METHOD_OF_VARIANT_TYPE = 25,
    GODOT_PROPERTY_HINT_METHOD_OF_BASE_TYPE = 26,
    GODOT_PROPERTY_HINT_METHOD_OF_INSTANCE = 27,
    GODOT_PROPERTY_HINT_METHOD_OF_SCRIPT = 28,
    GODOT_PROPERTY_HINT_PROPERTY_OF_VARIANT_TYPE = 29,
    GODOT_PROPERTY_HINT_PROPERTY_OF_BASE_TYPE = 30,
    GODOT_PROPERTY_HINT_PROPERTY_OF_INSTANCE = 31,
    GODOT_PROPERTY_HINT_PROPERTY_OF_SCRIPT = 32,
    GODOT_PROPERTY_HINT_MAX = 33,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum godot_property_usage_flags {
    GODOT_PROPERTY_USAGE_STORAGE = 1,
    GODOT_PROPERTY_USAGE_EDITOR = 2,
    GODOT_PROPERTY_USAGE_NETWORK = 4,
    GODOT_PROPERTY_USAGE_EDITOR_HELPER = 8,
    GODOT_PROPERTY_USAGE_CHECKABLE = 16,
    GODOT_PROPERTY_USAGE_CHECKED = 32,
    GODOT_PROPERTY_USAGE_INTERNATIONALIZED = 64,
    GODOT_PROPERTY_USAGE_GROUP = 128,
    GODOT_PROPERTY_USAGE_CATEGORY = 256,
    GODOT_PROPERTY_USAGE_STORE_IF_NONZERO = 512,
    GODOT_PROPERTY_USAGE_STORE_IF_NONONE = 1024,
    GODOT_PROPERTY_USAGE_NO_INSTANCE_STATE = 2048,
    GODOT_PROPERTY_USAGE_RESTART_IF_CHANGED = 4096,
    GODOT_PROPERTY_USAGE_SCRIPT_VARIABLE = 8192,
    GODOT_PROPERTY_USAGE_STORE_IF_NULL = 16384,
    GODOT_PROPERTY_USAGE_ANIMATE_AS_TRIGGER = 32768,
    GODOT_PROPERTY_USAGE_UPDATE_ALL_IF_MODIFIED = 65536,
    GODOT_PROPERTY_USAGE_DEFAULT = 7,
    GODOT_PROPERTY_USAGE_DEFAULT_INTL = 71,
    GODOT_PROPERTY_USAGE_NOEDITOR = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_property_attributes {
    pub rset_type: godot_method_rpc_mode,
    pub type_: godot_int,
    pub hint: godot_property_hint,
    pub hint_string: godot_string,
    pub usage: godot_property_usage_flags,
    pub default_value: godot_variant,
}
#[test]
fn bindgen_test_layout_godot_property_attributes() {
    assert_eq!(::std::mem::size_of::<godot_property_attributes>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_property_attributes ) ));
    assert_eq! (::std::mem::align_of::<godot_property_attributes>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_property_attributes )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_property_attributes ) ) . rset_type
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_property_attributes ) , "::" , stringify ! ( rset_type )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_property_attributes ) ) . type_ as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_property_attributes ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_property_attributes ) ) . hint as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_property_attributes ) , "::" , stringify ! ( hint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_property_attributes ) ) .
                hint_string as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_property_attributes ) , "::" , stringify ! ( hint_string
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_property_attributes ) ) . usage as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_property_attributes ) , "::" , stringify ! ( usage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_property_attributes ) ) .
                default_value as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_property_attributes ) , "::" , stringify ! (
                default_value ) ));
}
impl Clone for godot_property_attributes {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_instance_create_func {
    pub create_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut godot_object,
                                                                arg2:
                                                                    *mut ::std::os::raw::c_void)
                                               ->
                                                   *mut ::std::os::raw::c_void>,
    pub method_data: *mut ::std::os::raw::c_void,
    pub free_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_godot_instance_create_func() {
    assert_eq!(::std::mem::size_of::<godot_instance_create_func>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_instance_create_func ) ));
    assert_eq! (::std::mem::align_of::<godot_instance_create_func>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( godot_instance_create_func )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_instance_create_func ) ) .
                create_func as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_instance_create_func ) , "::" , stringify ! (
                create_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_instance_create_func ) ) .
                method_data as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_instance_create_func ) , "::" , stringify ! (
                method_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_instance_create_func ) ) .
                free_func as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_instance_create_func ) , "::" , stringify ! ( free_func
                ) ));
}
impl Clone for godot_instance_create_func {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_instance_destroy_func {
    pub destroy_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut godot_object,
                                                                 arg2:
                                                                     *mut ::std::os::raw::c_void,
                                                                 arg3:
                                                                     *mut ::std::os::raw::c_void)>,
    pub method_data: *mut ::std::os::raw::c_void,
    pub free_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_godot_instance_destroy_func() {
    assert_eq!(::std::mem::size_of::<godot_instance_destroy_func>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( godot_instance_destroy_func ) ));
    assert_eq! (::std::mem::align_of::<godot_instance_destroy_func>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( godot_instance_destroy_func )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_instance_destroy_func ) ) .
                destroy_func as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_instance_destroy_func ) , "::" , stringify ! (
                destroy_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_instance_destroy_func ) ) .
                method_data as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_instance_destroy_func ) , "::" , stringify ! (
                method_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_instance_destroy_func ) ) .
                free_func as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_instance_destroy_func ) , "::" , stringify ! ( free_func
                ) ));
}
impl Clone for godot_instance_destroy_func {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_script_register_class(p_name: *const ::std::os::raw::c_char,
                                       p_base: *const ::std::os::raw::c_char,
                                       p_create_func:
                                           godot_instance_create_func,
                                       p_destroy_func:
                                           godot_instance_destroy_func);
}
extern "C" {
    pub fn godot_script_register_tool_class(p_name:
                                                *const ::std::os::raw::c_char,
                                            p_base:
                                                *const ::std::os::raw::c_char,
                                            p_create_func:
                                                godot_instance_create_func,
                                            p_destroy_func:
                                                godot_instance_destroy_func);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_instance_method {
    pub method: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut godot_object,
                                                           arg2:
                                                               *mut ::std::os::raw::c_void,
                                                           arg3:
                                                               *mut ::std::os::raw::c_void,
                                                           arg4:
                                                               ::std::os::raw::c_int,
                                                           arg5:
                                                               *mut *mut godot_variant)
                                          -> godot_variant>,
    pub method_data: *mut ::std::os::raw::c_void,
    pub free_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_godot_instance_method() {
    assert_eq!(::std::mem::size_of::<godot_instance_method>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( godot_instance_method )
               ));
    assert_eq! (::std::mem::align_of::<godot_instance_method>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_instance_method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_instance_method ) ) . method as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_instance_method )
                , "::" , stringify ! ( method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_instance_method ) ) . method_data
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_instance_method )
                , "::" , stringify ! ( method_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_instance_method ) ) . free_func as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_instance_method )
                , "::" , stringify ! ( free_func ) ));
}
impl Clone for godot_instance_method {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_script_register_method(p_name: *const ::std::os::raw::c_char,
                                        p_function_name:
                                            *const ::std::os::raw::c_char,
                                        p_attr: godot_method_attributes,
                                        p_method: godot_instance_method);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_property_set_func {
    pub set_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut godot_object,
                                                             arg2:
                                                                 *mut ::std::os::raw::c_void,
                                                             arg3:
                                                                 *mut ::std::os::raw::c_void,
                                                             arg4:
                                                                 godot_variant)>,
    pub method_data: *mut ::std::os::raw::c_void,
    pub free_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_godot_property_set_func() {
    assert_eq!(::std::mem::size_of::<godot_property_set_func>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_property_set_func ) ));
    assert_eq! (::std::mem::align_of::<godot_property_set_func>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_property_set_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_property_set_func ) ) . set_func as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_property_set_func
                ) , "::" , stringify ! ( set_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_property_set_func ) ) . method_data
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_property_set_func
                ) , "::" , stringify ! ( method_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_property_set_func ) ) . free_func
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_property_set_func
                ) , "::" , stringify ! ( free_func ) ));
}
impl Clone for godot_property_set_func {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_property_get_func {
    pub get_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut godot_object,
                                                             arg2:
                                                                 *mut ::std::os::raw::c_void,
                                                             arg3:
                                                                 *mut ::std::os::raw::c_void)
                                            -> godot_variant>,
    pub method_data: *mut ::std::os::raw::c_void,
    pub free_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_godot_property_get_func() {
    assert_eq!(::std::mem::size_of::<godot_property_get_func>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_property_get_func ) ));
    assert_eq! (::std::mem::align_of::<godot_property_get_func>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_property_get_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_property_get_func ) ) . get_func as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_property_get_func
                ) , "::" , stringify ! ( get_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_property_get_func ) ) . method_data
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_property_get_func
                ) , "::" , stringify ! ( method_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_property_get_func ) ) . free_func
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_property_get_func
                ) , "::" , stringify ! ( free_func ) ));
}
impl Clone for godot_property_get_func {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_script_register_property(p_name:
                                              *const ::std::os::raw::c_char,
                                          p_path:
                                              *const ::std::os::raw::c_char,
                                          p_attr:
                                              *mut godot_property_attributes,
                                          p_set_func: godot_property_set_func,
                                          p_get_func:
                                              godot_property_get_func);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_signal_argument {
    pub name: godot_string,
    pub type_: godot_int,
    pub hint: godot_property_hint,
    pub hint_string: godot_string,
    pub usage: godot_property_usage_flags,
    pub default_value: godot_variant,
}
#[test]
fn bindgen_test_layout_godot_signal_argument() {
    assert_eq!(::std::mem::size_of::<godot_signal_argument>() , 52usize ,
               concat ! ( "Size of: " , stringify ! ( godot_signal_argument )
               ));
    assert_eq! (::std::mem::align_of::<godot_signal_argument>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_signal_argument ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_signal_argument ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal_argument )
                , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_signal_argument ) ) . type_ as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal_argument )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_signal_argument ) ) . hint as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal_argument )
                , "::" , stringify ! ( hint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_signal_argument ) ) . hint_string
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal_argument )
                , "::" , stringify ! ( hint_string ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_signal_argument ) ) . usage as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal_argument )
                , "::" , stringify ! ( usage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_signal_argument ) ) . default_value
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal_argument )
                , "::" , stringify ! ( default_value ) ));
}
impl Clone for godot_signal_argument {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_signal {
    pub name: godot_string,
    pub num_args: ::std::os::raw::c_int,
    pub args: *mut godot_signal_argument,
    pub num_default_args: ::std::os::raw::c_int,
    pub default_args: *mut godot_variant,
}
#[test]
fn bindgen_test_layout_godot_signal() {
    assert_eq!(::std::mem::size_of::<godot_signal>() , 40usize , concat ! (
               "Size of: " , stringify ! ( godot_signal ) ));
    assert_eq! (::std::mem::align_of::<godot_signal>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( godot_signal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_signal ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_signal ) ) . num_args as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal ) , "::" ,
                stringify ! ( num_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_signal ) ) . args as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_signal ) ) . num_default_args as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal ) , "::" ,
                stringify ! ( num_default_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const godot_signal ) ) . default_args as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal ) , "::" ,
                stringify ! ( default_args ) ));
}
impl Clone for godot_signal {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_script_register_signal(p_name: *const ::std::os::raw::c_char,
                                        p_signal: *const godot_signal);
}
extern "C" {
    pub fn godot_native_get_userdata(p_instance: *mut godot_object)
     -> *mut ::std::os::raw::c_void;
}
pub type godot_class_constructor =
    ::std::option::Option<unsafe extern "C" fn() -> *mut godot_object>;
extern "C" {
    pub fn godot_get_class_constructor(p_classname:
                                           *const ::std::os::raw::c_char)
     -> godot_class_constructor;
}
extern "C" {
    pub fn godot_get_global_constants() -> godot_dictionary;
}
extern "C" {
    ////// System Functions
    pub fn godot_alloc(p_bytes: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn godot_realloc(p_ptr: *mut ::std::os::raw::c_void,
                         p_bytes: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn godot_free(p_ptr: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
